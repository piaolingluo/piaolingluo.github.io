---
title: 第一章 Java内存区域与内存溢出异常
order: 1
tag:
 - JVM
---

## 对象内存分配方式

### 指针碰撞

假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针**向空闲空间方向挪动一段与对象大小相等的距离**，这种分配方式称为“指针碰撞”(Bump The Pointer)。

### 空闲列表

如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须**维护一个列表，记录上哪些内存块是可用的**，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。

## 对象的内存布局

在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：**对象头(Header)**、**实例数据(Instance Data)**和**对齐填充(Padding)**。

### 对象头

对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据(`Mark Word`)，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另外一部分是类型指针(`Class Metadata Address`)，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。

如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度(`Array Length`)的数据。

### 实例数据

实例数据部分是对象真正存储的有效信息，HotSpot虚拟机默认的分配顺序为 longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)，从以上默认的分配策略中可以看到，**相同宽度的字段总是被分配到一起存放**，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。

### 对齐填充

任何对象的大小都必须是**8字节的整数倍**。因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

## 对象的访问定位

### 句柄访问

如果使用句柄访问的话，Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的**句柄地址**，而句柄中包含了对象**实例数据指针**和**类型数据指针**。

![通过句柄访问对象](./image/通过句柄访问对象.png)

优点：reference 中存储的是**稳定句柄地址**，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。

缺点：相比`直接指针访问`，多一次指针定位的时间开销。

### 直接指针访问

**HotSpot 中访问对象的主要方式是直接指针**。如果使用直接指针访问的话，reference 中存储的就是**对象地址**，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

![通过直接指针访问对象](./image/通过直接指针访问对象.png)

优点：速度更快，它节省了一次指针定位的时间开销。

## 运行时数据区和直接内存 OOM 异常情况

在《Java虚拟机规范》的规定里，**除了程序计数器**，虚拟机内存的其他几个运行时区域都有可能发生 OutOfMemoryError 异常。

### Java 堆溢出

通过参数 `-XX:+HeapDumpOnOutOfMemoryError` 可以让虚拟机在出现内存溢出异常的时候 Dump 出当前的内存堆转储快照以便进行事后分析。

![Java堆内存溢出异常测试](./image/Java堆内存溢出异常测试.png)

通过内存映像分析工具(如mat)进行堆转储快照分析：

![分析结果](./image/mat分析dump文件.png)

::: tip

mat 的使用请参考：[内存 dump 分析工具 - mat](./tool-mat.md)

:::

1. 如果是内存泄漏(Memory Leak)，可进一步通过工具查看泄漏对象到 `GC Roots` 的引用链，根据泄漏对象的类型信息以及它到 `GC Roots` 引用链的信息，一般可以比较准确地定位到这些对象创建的位置。

2. 如果内存中的对象确实都是必须存活的，就代表是内存溢出(`Memory Overflow`)，那就应当检查 Java 虚拟机的堆参数(`-Xmx` 与 `-Xms`)设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些**对象生命周期过长**、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

### 虚拟机栈和本地方法栈溢出

HotSpot 虚拟机中并**不区分虚拟机栈和本地方法栈**， 栈容量只能由 `-Xss` 参数来设定。

$$
栈的深度 = \frac{栈容量}{平均每个栈帧的大小}
$$

栈容量固定的情况下，栈的最大深度与平均每个栈帧的大小成反比。

对于 HotSpot 虚拟机而言，当栈容量无法容纳新的栈帧时，会引发 StackOverflowError 异常。当**创建线程**申请内存时，无法获得足够的内存，会引发 OutOfMemoryError 异常。

创建线程导致内存溢出异常案例：

![](./image/创建线程导致内存溢出异常.png)

::: danger 注意

重点提示一下，如果读者要尝试运行上面这段代码，记得要先保存当前的工作，由于在 Windows 平台的虚拟机中，Java 的线程是映射到操作系统的内核线程上，无限制地创建线程会对操作系统带来很大压力，上述代码执行时有很高的风险，可能会由于创建线程数量过多而导致操作系统假死。

:::

### 方法区和运行时常量池溢出

#### 字符串常量池导致的内存溢出异常
在 **JDK 6 或更早之前的 HotSpot 虚拟机中，运行时常量池和字符串常量池都是分配在永久代中**，我们可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 限制永久代的大小，即可间接限制其中常量池的容量。我们使用 JDK 6 来运行以下代码。

![](./image/字符串常量池导致的内存溢出异常.png)

**自JDK 7起，原本存放在永久代的字符串常量池被移至 Java 堆之中**。

#### 方法区内存溢出异常

方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。

填满方法区的方法有：

- JDK 动态代理生成大量动态类
- CGLib 生成大量动态类
- 动态语言(例如 Groovy 等)
- 大量 JSP 或动态产生 JSP 文件的应用(JSP 第一次运行时需要编译为 Java 类)
- 基于 OSGi 的应用(即使是同一个类文件，被不同的加载器加载也会视为不同的类)

::: warning
JDK 8 之前，方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件是比较苛刻的。在运行时**经常生成大量动态类**的应用场景里，就应该特别关注这些类的回收状况。
:::

#### JDK 8 以后，HotSpot 对元空间的保护

**在 JDK 8 以后，元空间完全替代了永久代**。在实际应用中，**为了预防大量动态类占用内存空间的情况**，HotSpot 提供了一些参数作为元空间的防御措施，主要包括：

- `-XX:MaxMetaspaceSize`：设置元空间最大值，**默认是 -1，即不限制**，或者说只受限于本地内存大小。
- `-XX:MetaspaceSize`：指定元空间的初始空间大小，以字节为单位，**达到该值就会触发垃圾收集进行类型卸载**，同时收集器会对该值进行调整：
  - 如果释放了大量的空间，就适当降低该值;
  - 如果释放了很少的空间，那么在不超过 `-XX:MaxMetaspaceSize` (如果设置了的话)的情况下，适当提高该值。

### 本机直接内存溢出

直接内存(`Direct Memory`)的容量大小可通过 `-XX:MaxDirectMemorySize` 参数来指定，如果不去指定，则**默认与Java堆最大值(由 `-Xmx`指定)一致**。

由直接内存导致的内存溢出，一个明显的特征是在 **`Heap Dump` 文件中没有明显的异常**，如果读者发现内存溢出之后产生的 **Dump 文件很小**，而程序中又直接或间接**使用了 DirectMemory (典型的间接使用就是NIO)**，那就可以重点检查一下直接内存方面的原因了。