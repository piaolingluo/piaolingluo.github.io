import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as i,c as a,b as t,f as r}from"./app-60796361.js";const s="/assets/G1收集器Region分区示意图-a097bf63.png",g="/assets/G1收集器运行示意图-891f974f.png",c={},d=r('<h2 id="经典垃圾收集器" tabindex="-1"><a class="header-anchor" href="#经典垃圾收集器" aria-hidden="true">#</a> 经典垃圾收集器</h2><h3 id="g1-收集器" tabindex="-1"><a class="header-anchor" href="#g1-收集器" aria-hidden="true">#</a> G1 收集器</h3><p>G1（<code>Garbage First</code>）是一款主要面向<strong>服务端</strong>应用的垃圾收集器。它是垃圾收集器技术发展史上里程碑式的成果，开创了收集器面向<strong>局部收集</strong>的设计思路和基于 <strong>Region</strong> 的内存布局形式。</p><p>JDK 9 发布之日，G1 宣告取代 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 组合，成为服务端模式下的默认垃圾收集器，而 CMS 则被声明为不推荐使用（Deprecate）的收集器。</p><h4 id="g1-设计的目标-——-建立-停顿时间模型" tabindex="-1"><a class="header-anchor" href="#g1-设计的目标-——-建立-停顿时间模型" aria-hidden="true">#</a> G1 设计的目标 —— 建立“停顿时间模型”</h4><blockquote><p>停顿时间模型（<code>Pause Prediction Model</code>）的意思是能够支持指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过 N 毫秒这样的目标。</p></blockquote><h4 id="g1-的设计思想" tabindex="-1"><a class="header-anchor" href="#g1-的设计思想" aria-hidden="true">#</a> G1 的设计思想</h4><p>G1 可以选择堆内存任何部分组成回收集（<code>Collection Set</code>， 一般简称 CSet），进行回收。哪块内存中存放的垃圾数量最多，回收收益最大，就优先回收哪块内存。这就是 G1 收集器的 <code>Mixed GC</code> 模式。</p><h4 id="g1-的具体实现" tabindex="-1"><a class="header-anchor" href="#g1-的具体实现" aria-hidden="true">#</a> G1 的具体实现</h4><p>G1 把连续的 Java 堆划分为<strong>多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间</strong>。</p><p>Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。G1 认为只要大小超过了一个 <strong>Region 容量一半</strong>的对象即可判定为大对象。每个 Region 的大小可以通过参数 <code>-XX:G1HeapRegionSize</code> 设定，取值范围为 <strong>1MB ~ 32MB，且应为 2 的 N 次幂</strong>。而对于那些超过了整个 Region 容量的超级大对象，将会被存放在 N 个连续的 <code>Humongous Region</code> 之中，G1 的大多数行为都把 <code>Humongous Region</code> 作为老年代的一部分来进行看待。</p><figure><img src="'+s+'" alt="G1 收集器 Region 分区示意图" tabindex="0" loading="lazy"><figcaption>G1 收集器 Region 分区示意图</figcaption></figure><p>G1 收集器要怎么做才能满足用户的期望（<code>-XX:MaxGCPauseMillis</code>）呢？G1 收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1 收集器会记录每个 Region 的回收耗时、每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。然后通过这些信息预测现在开始回收的话，由哪些 Region 组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“<strong>最近的</strong>”平均状态。换句话说，<strong>Region 的统计状态越新越能决定其回收的价值</strong>。</p></div><p>G1 收集器的运作过程大致可划分为以下四个步骤：</p><ul><li><p>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段<strong>需要停顿线程（STW）</strong>，但耗时很短，而且是借用进行 <code>Minor GC</code> 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。</p></li><li><p>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可<strong>与用户程序并发执行</strong>。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。</p></li><li><p>最终标记（Final Marking）：对用户线程做另一个<strong>短暂的暂停（STW）</strong>，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。</p></li><li><p>筛选回收（Live Data Counting and Evacuation）：负责更新 Region 的<strong>统计</strong>数据，对各个 Region 的回收价值和成本进行<strong>排序</strong>，根据用户所期望的停顿时间来制定<strong>回收计划</strong>，可以自由选择任意多个 Region 构成<strong>回收集</strong>，然后把决定回收的那一部分 Region 的存活对象<strong>复制</strong>到空的 Region 中，再<strong>清理</strong>掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须<strong>暂停用户线程（STW）</strong>，由<strong>多条收集器线程并行完成</strong>的。</p></li></ul><figure><img src="'+g+'" alt="G1 收集器运行示意图" tabindex="0" loading="lazy"><figcaption>G1 收集器运行示意图</figcaption></figure><div class="hint-container info"><p class="hint-container-title">MaxGCPauseMillis 怎样设置合理</p><p>如果我们把停顿时间调得非常低，就可能导致每次选出来的回收集只占堆内存很小的一部分，收集器<strong>收集的速度逐渐跟不上分配器分配的速度</strong>，导致垃圾慢慢堆积。应用运行一段时间后，最终占满堆，引发 <code>Full GC</code>，从而降低性能。所以通常把 MaxGCPauseMillis 设置为一两百毫秒或者两三百毫秒会是比较合理的。</p></div><h4 id="g1-的优点" tabindex="-1"><a class="header-anchor" href="#g1-的优点" aria-hidden="true">#</a> G1 的优点</h4><ul><li>可以通过 <code>-XX:MaxGCPauseMillis</code> 指定最大停顿时间，默认 200ms。</li><li>分 Region 的内存布局，和按收益动态确定回收集的创新设计。</li><li>运作期间<strong>不会产生内存空间碎片</strong>。</li></ul><h4 id="g1-的缺点" tabindex="-1"><a class="header-anchor" href="#g1-的缺点" aria-hidden="true">#</a> G1 的缺点</h4><p>内存消耗大，G1 至少要耗费大约相当于 Java 堆容量 10% 至 20% 的额外内存来维持收集器工作。</p><div class="hint-container info"><p class="hint-container-title">选择 CMS 还是 G1？</p><p>小内存应用上 CMS 的表现大概率仍然要会优于 G1，而在大内存应用上 G1 则大多能发挥其优势。</p></div><h4 id="关于-g1-的视频介绍" tabindex="-1"><a class="header-anchor" href="#关于-g1-的视频介绍" aria-hidden="true">#</a> 关于 G1 的视频介绍</h4>',24);function l(h,p){const e=n("YouTube");return i(),a("div",null,[d,t(e,{id:"2PIBF92iOvQ"})])}const f=o(c,[["render",l],["__file","chap-two.html.vue"]]);export{f as default};
