import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as n,f as l,d as s,e as a}from"./app-3506b06e.js";const i="/assets/CPU缓存与内存结构-1ffa2709.png",c="/assets/典型的缓存结构示意图-b85ba7a8.png",o={},r=l('<p>在多线程并发编程中，volatile [/ˈvɒlətaɪl/] 和 synchronized 扮演着重要的角色。在多核处理器中，volatile 保证了共享变量的<strong>可见性</strong>，当一个线程修改共享变量时，另一个线程能够立即读取到修改后的值。在了解其实现原理之前，我们有必要了解一下 CPU 缓存相关知识。</p><h2 id="物理内存与-cpu-缓存" tabindex="-1"><a class="header-anchor" href="#物理内存与-cpu-缓存" aria-hidden="true">#</a> 物理内存与 CPU 缓存</h2><p>CPU 在执行过程中，可以通过<strong>访存指令</strong>向物理内存中写入数据或者从其中读取数据。CPU 使用物理内存的方式很简单：通过总线向物理内存发送一个读写请求，其中包括<strong>目标地址</strong>（若是写请求，则还包括写入值），物理内存在收到请求后进行读写操作（若是读请求，则将读取值发送回 CPU）。因此从 CPU 的角度，可以把物理内存看作由字节组成的大数组：其中每一个字节拥有一个地址（物理地址），CPU 可以在这个数组中存取数据。</p><p>然而，相比于 CPU 处理的速度，内存访问速度是非常缓慢的：一条算术运算指令可能只需要一个或几个时钟周期即可完成，而一次内存的访问则可能需要花费上百个时钟周期。为了降低 CPU 访存的开销，现在的 CPU 中通常引入了缓存（cache），用于存放一部分物理内存中的数据。访问 CPU 缓存比访问物理内存要快很多，一般最快只需要几个时钟周期。当 CPU 需要向物理内存写入数据的时候，它可以直接写在 CPU 缓存之中；当 CPU 需要从物理内存读取数据的时候，它可以先在 CPU 缓存中查找，如果没找到再去物理内存中获取，并且把取回的数据放入缓存中，以便加快下次读取速度。</p><figure><img src="'+i+'" alt="CPU缓存与内存结构" tabindex="0" loading="lazy"><figcaption>CPU缓存与内存结构</figcaption></figure><h3 id="缓存结构" tabindex="-1"><a class="header-anchor" href="#缓存结构" aria-hidden="true">#</a> 缓存结构</h3><p>CPU 缓存是由若干个缓存行（<code>cache line</code>）组成的。每个缓存行包括：一个有效位（<code>valid bit</code>），用于表示其是否有效；—个标记地址（<code>tag address</code>），用于标识其对应的物理地址；一些其他的状态信息。通常，CPU 以缓存行（常见的是 64 字节）为单位把物理内存中的数据读取到 CPU 缓存中，也就是说即使只需要单个字节的值，该字节对应的缓存行也会全部进入缓存中。同样，将数据写回到物理内存也是以缓存行为单位的。</p><figure><img src="'+c+'" alt="典型的缓存结构示意图" tabindex="0" loading="lazy"><figcaption>典型的缓存结构示意图</figcaption></figure>',8),p=s("p",null,[a("为了通过内存的物理地址找到对应的缓存，物理地址在逻辑上分为 Tag、Set（也称为 Index）以及 Offset 三段。组（Set）与路（Way）是 CPU 缓存的经典概念。物理地址中的 Set 段能表示的最大数目称为组。例如，如果 Set 段的位数是 8，那么对应的 CPU 缓存的组数就是 256（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mn",null,"8")]),s("mo",null,"="),s("mn",null,"256")]),s("annotation",{encoding:"application/x-tex"},"2^8 = 256")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"8")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"256")])])]),a("）。同一组（即 Set 段相等）下，支持的最大 Tag 数则称为路，即同一组下的缓存行数目。例如上图中，在 Set 相同的情况下，缓存最多支持 4 个不同的 Tag，也就是 4 路，该 CPU 缓存被称为 4 路组相联（4-Way Set Associative）。")],-1),d=s("h2",{id:"volatile-的实现原理",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#volatile-的实现原理","aria-hidden":"true"},"#"),a(" volatile 的实现原理")],-1),h=s("blockquote",null,[s("p",null,"如果一个字段被声明成 volatile，Java 线程内存模型确保所有线程看到这个变量的值是一致的。")],-1),m=[r,p,d,h];function g(u,_){return t(),n("div",null,m)}const P=e(o,[["render",g],["__file","chap-zero.html.vue"]]);export{P as default};
