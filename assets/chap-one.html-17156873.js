import{_ as r}from"./mat分析dump文件-02936f5b.js";import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as i,c,d as a,e as s,b as d,w as l,f as e}from"./app-73edf2ad.js";const p="/assets/通过句柄访问对象-57ff4b39.png",h="/assets/通过直接指针访问对象-c89c4de3.png",g="/assets/Java堆内存溢出异常测试-7f5a714f.png",m="/assets/创建线程导致内存溢出异常-621004a9.png",f="/assets/字符串常量池导致的内存溢出异常-4da71f37.png",u={},x=e('<h2 id="对象内存分配方式" tabindex="-1"><a class="header-anchor" href="#对象内存分配方式" aria-hidden="true">#</a> 对象内存分配方式</h2><h3 id="指针碰撞" tabindex="-1"><a class="header-anchor" href="#指针碰撞" aria-hidden="true">#</a> 指针碰撞</h3><p>假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针<strong>向空闲空间方向挪动一段与对象大小相等的距离</strong>，这种分配方式称为“指针碰撞”(Bump The Pointer)。</p><h3 id="空闲列表" tabindex="-1"><a class="header-anchor" href="#空闲列表" aria-hidden="true">#</a> 空闲列表</h3><p>如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须<strong>维护一个列表，记录上哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。</p><h2 id="对象的内存布局" tabindex="-1"><a class="header-anchor" href="#对象的内存布局" aria-hidden="true">#</a> 对象的内存布局</h2><p>在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头(Header)</strong>、<strong>实例数据(Instance Data)<strong>和</strong>对齐填充(Padding)</strong>。</p><h3 id="对象头" tabindex="-1"><a class="header-anchor" href="#对象头" aria-hidden="true">#</a> 对象头</h3><p>对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据(<code>Mark Word</code>)，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另外一部分是类型指针(<code>Class Metadata Address</code>)，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度(<code>Array Length</code>)的数据。</p><h3 id="实例数据" tabindex="-1"><a class="header-anchor" href="#实例数据" aria-hidden="true">#</a> 实例数据</h3><p>实例数据部分是对象真正存储的有效信息，HotSpot虚拟机默认的分配顺序为 longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)，从以上默认的分配策略中可以看到，<strong>相同宽度的字段总是被分配到一起存放</strong>，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</p><h3 id="对齐填充" tabindex="-1"><a class="header-anchor" href="#对齐填充" aria-hidden="true">#</a> 对齐填充</h3><p>任何对象的大小都必须是<strong>8字节的整数倍</strong>。因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位" tabindex="-1"><a class="header-anchor" href="#对象的访问定位" aria-hidden="true">#</a> 对象的访问定位</h2><h3 id="句柄访问" tabindex="-1"><a class="header-anchor" href="#句柄访问" aria-hidden="true">#</a> 句柄访问</h3><p>如果使用句柄访问的话，Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的<strong>句柄地址</strong>，而句柄中包含了对象<strong>实例数据指针</strong>和<strong>类型数据指针</strong>。</p><figure><img src="'+p+'" alt="通过句柄访问对象" tabindex="0" loading="lazy"><figcaption>通过句柄访问对象</figcaption></figure><p>优点：reference 中存储的是<strong>稳定句柄地址</strong>，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。</p><p>缺点：相比<code>直接指针访问</code>，多一次指针定位的时间开销。</p><h3 id="直接指针访问" tabindex="-1"><a class="header-anchor" href="#直接指针访问" aria-hidden="true">#</a> 直接指针访问</h3><p><strong>HotSpot 中访问对象的主要方式是直接指针</strong>。如果使用直接指针访问的话，reference 中存储的就是<strong>对象地址</strong>，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><figure><img src="'+h+'" alt="通过直接指针访问对象" tabindex="0" loading="lazy"><figcaption>通过直接指针访问对象</figcaption></figure><p>优点：速度更快，它节省了一次指针定位的时间开销。</p><h2 id="运行时数据区和直接内存-oom-异常情况" tabindex="-1"><a class="header-anchor" href="#运行时数据区和直接内存-oom-异常情况" aria-hidden="true">#</a> 运行时数据区和直接内存 OOM 异常情况</h2><p>在《Java虚拟机规范》的规定里，<strong>除了程序计数器</strong>，虚拟机内存的其他几个运行时区域都有可能发生 OutOfMemoryError 异常。</p><h3 id="java-堆溢出" tabindex="-1"><a class="header-anchor" href="#java-堆溢出" aria-hidden="true">#</a> Java 堆溢出</h3><p>通过参数 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 可以让虚拟机在出现内存溢出异常的时候 Dump 出当前的内存堆转储快照以便进行事后分析。</p><figure><img src="'+g+'" alt="Java堆内存溢出异常测试" tabindex="0" loading="lazy"><figcaption>Java堆内存溢出异常测试</figcaption></figure><p>通过内存映像分析工具(如mat)进行堆转储快照分析：</p><figure><img src="'+r+'" alt="分析结果" tabindex="0" loading="lazy"><figcaption>分析结果</figcaption></figure>',31),_={class:"hint-container tip"},b=a("p",{class:"hint-container-title"},"提示",-1),v=e('<ol><li><p>如果是内存泄漏(Memory Leak)，可进一步通过工具查看泄漏对象到 <code>GC Roots</code> 的引用链，根据泄漏对象的类型信息以及它到 <code>GC Roots</code> 引用链的信息，一般可以比较准确地定位到这些对象创建的位置。</p></li><li><p>如果内存中的对象确实都是必须存活的，就代表是内存溢出(<code>Memory Overflow</code>)，那就应当检查 Java 虚拟机的堆参数(<code>-Xmx</code> 与 <code>-Xms</code>)设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些<strong>对象生命周期过长</strong>、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</p></li></ol><h3 id="虚拟机栈和本地方法栈溢出" tabindex="-1"><a class="header-anchor" href="#虚拟机栈和本地方法栈溢出" aria-hidden="true">#</a> 虚拟机栈和本地方法栈溢出</h3><p>HotSpot 虚拟机中并<strong>不区分虚拟机栈和本地方法栈</strong>， 栈容量只能由 <code>-Xss</code> 参数来设定。</p>',3),y=a("p",{class:"katex-block"},[a("span",{class:"katex-display"},[a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("semantics",null,[a("mrow",null,[a("mtext",null,"栈的深度"),a("mo",null,"="),a("mfrac",null,[a("mtext",null,"栈容量"),a("mtext",null,"平均每个栈帧的大小")])]),a("annotation",{encoding:"application/x-tex"}," 栈的深度 = \\frac{栈容量}{平均每个栈帧的大小} ")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord cjk_fallback"},"栈的深度"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"2.0463em","vertical-align":"-0.686em"}}),a("span",{class:"mord"},[a("span",{class:"mopen nulldelimiter"}),a("span",{class:"mfrac"},[a("span",{class:"vlist-t vlist-t2"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"1.3603em"}},[a("span",{style:{top:"-2.314em"}},[a("span",{class:"pstrut",style:{height:"3em"}}),a("span",{class:"mord"},[a("span",{class:"mord cjk_fallback"},"平均每个栈帧的大小")])]),a("span",{style:{top:"-3.23em"}},[a("span",{class:"pstrut",style:{height:"3em"}}),a("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),a("span",{style:{top:"-3.677em"}},[a("span",{class:"pstrut",style:{height:"3em"}}),a("span",{class:"mord"},[a("span",{class:"mord cjk_fallback"},"栈容量")])])]),a("span",{class:"vlist-s"},"​")]),a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.686em"}},[a("span")])])])]),a("span",{class:"mclose nulldelimiter"})])])])])])],-1),J=e('<p>栈容量固定的情况下，栈的最大深度与平均每个栈帧的大小成反比。</p><p>对于 HotSpot 虚拟机而言，当栈容量无法容纳新的栈帧时，会引发 StackOverflowError 异常。当<strong>创建线程</strong>申请内存时，无法获得足够的内存，会引发 OutOfMemoryError 异常。</p><p>创建线程导致内存溢出异常案例：</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container danger"><p class="hint-container-title">注意</p><p>重点提示一下，如果读者要尝试运行上面这段代码，记得要先保存当前的工作，由于在 Windows 平台的虚拟机中，Java 的线程是映射到操作系统的内核线程上，无限制地创建线程会对操作系统带来很大压力，上述代码执行时有很高的风险，可能会由于创建线程数量过多而导致操作系统假死。</p></div><h3 id="方法区和运行时常量池溢出" tabindex="-1"><a class="header-anchor" href="#方法区和运行时常量池溢出" aria-hidden="true">#</a> 方法区和运行时常量池溢出</h3><h4 id="字符串常量池导致的内存溢出异常" tabindex="-1"><a class="header-anchor" href="#字符串常量池导致的内存溢出异常" aria-hidden="true">#</a> 字符串常量池导致的内存溢出异常</h4><p>在 <strong>JDK 6 或更早之前的 HotSpot 虚拟机中，运行时常量池和字符串常量池都是分配在永久代中</strong>，我们可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 限制永久代的大小，即可间接限制其中常量池的容量。我们使用 JDK 6 来运行以下代码。</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>自JDK 7起，原本存放在永久代的字符串常量池被移至 Java 堆之中</strong>。</p><h4 id="方法区内存溢出异常" tabindex="-1"><a class="header-anchor" href="#方法区内存溢出异常" aria-hidden="true">#</a> 方法区内存溢出异常</h4><p>方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p><p>填满方法区的方法有：</p><ul><li>JDK 动态代理生成大量动态类</li><li>CGLib 生成大量动态类</li><li>动态语言(例如 Groovy 等)</li><li>大量 JSP 或动态产生 JSP 文件的应用(JSP 第一次运行时需要编译为 Java 类)</li><li>基于 OSGi 的应用(即使是同一个类文件，被不同的加载器加载也会视为不同的类)</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>JDK 8 之前，方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件是比较苛刻的。在运行时<strong>经常生成大量动态类</strong>的应用场景里，就应该特别关注这些类的回收状况。</p></div><h4 id="jdk-8-以后-hotspot-对元空间的保护" tabindex="-1"><a class="header-anchor" href="#jdk-8-以后-hotspot-对元空间的保护" aria-hidden="true">#</a> JDK 8 以后，HotSpot 对元空间的保护</h4><p><strong>在 JDK 8 以后，元空间完全替代了永久代</strong>。在实际应用中，<strong>为了预防大量动态类占用内存空间的情况</strong>，HotSpot 提供了一些参数作为元空间的防御措施，主要包括：</p><ul><li><code>-XX:MaxMetaspaceSize</code>：设置元空间最大值，<strong>默认是 -1，即不限制</strong>，或者说只受限于本地内存大小。</li><li><code>-XX:MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，<strong>达到该值就会触发垃圾收集进行类型卸载</strong>，同时收集器会对该值进行调整： <ul><li>如果释放了大量的空间，就适当降低该值;</li><li>如果释放了很少的空间，那么在不超过 <code>-XX:MaxMetaspaceSize</code> (如果设置了的话)的情况下，适当提高该值。</li></ul></li></ul><h3 id="本机直接内存溢出" tabindex="-1"><a class="header-anchor" href="#本机直接内存溢出" aria-hidden="true">#</a> 本机直接内存溢出</h3><p>直接内存(<code>Direct Memory</code>)的容量大小可通过 <code>-XX:MaxDirectMemorySize</code> 参数来指定，如果不去指定，则<strong>默认与Java堆最大值(由 <code>-Xmx</code>指定)一致</strong>。</p><p>由直接内存导致的内存溢出，一个明显的特征是在 <strong><code>Heap Dump</code> 文件中没有明显的异常</strong>，如果读者发现内存溢出之后产生的 <strong>Dump 文件很小</strong>，而程序中又直接或间接<strong>使用了 DirectMemory (典型的间接使用就是NIO)</strong>，那就可以重点检查一下直接内存方面的原因了。</p>',21);function k(M,S){const t=n("RouterLink");return i(),c("div",null,[x,a("div",_,[b,a("p",null,[s("mat 的使用请参考："),d(t,{to:"/notes/jvm/tool-mat.html"},{default:l(()=>[s("内存 dump 分析工具 - mat")]),_:1})])]),v,y,J])}const w=o(u,[["render",k],["__file","chap-one.html.vue"]]);export{w as default};
